// 1. IMPORTAÇÕES E CONFIGURAÇÕES
const express = require('express');
const sqlite3 = require('sqlite3').verbose();
const path = require('path');
const fs = require('fs');
const ExcelJS = require('exceljs');
const session = require('express-session');
const bcrypt = require('bcrypt');
const app = express();
const PORT = 3000;
const DB_PATH = path.join(__dirname, 'data', 'relatorios.db');
const TXT_FOLDER_PATH = path.join(__dirname, 'data', 'txts');
fs.mkdirSync(TXT_FOLDER_PATH, { recursive: true });

// 2. BANCO DE DADOS
const db = new sqlite3.Database(DB_PATH, (err) => {
    if (err) return console.error("Erro ao conectar:", err.message);
    console.log("Conectado ao banco de dados (v11 - Design VIVO).");
    db.serialize(() => {
        db.run(`CREATE TABLE IF NOT EXISTS usuarios (id INTEGER PRIMARY KEY AUTOINCREMENT, username TEXT UNIQUE NOT NULL, password TEXT NOT NULL, role TEXT NOT NULL)`);
        const users = [{ username: 'admin', password: 'admin', role: 'admin' }, { username: 'monitoramento', password: '1212', role: 'monitoramento' }];
        users.forEach(user => { bcrypt.hash(user.password, 10, (err, hash) => { if (err) return; db.run('INSERT OR IGNORE INTO usuarios (username, password, role) VALUES (?, ?, ?)', [user.username, hash, user.role]); }); });
        db.run(`CREATE TABLE IF NOT EXISTS lojas (id INTEGER PRIMARY KEY AUTOINCREMENT, nome TEXT UNIQUE NOT NULL, funcao_especial TEXT, observacoes TEXT, meta_tx_loja REAL DEFAULT 20, meta_tx_monitoramento REAL DEFAULT 15)`);
        db.run(`CREATE TABLE IF NOT EXISTS demandas (id INTEGER PRIMARY KEY AUTOINCREMENT, loja_nome TEXT, descricao TEXT NOT NULL, tag TEXT NOT NULL, status TEXT DEFAULT 'pendente', criado_em DATETIME DEFAULT CURRENT_TIMESTAMP)`);
        db.run(`CREATE TABLE IF NOT EXISTS relatorios (id INTEGER PRIMARY KEY AUTOINCREMENT, loja TEXT NOT NULL, data TEXT NOT NULL, clientes_monitoramento INTEGER, clientes_loja INTEGER, vendas_monitoramento INTEGER, vendas_loja INTEGER, hora_abertura TEXT, hora_fechamento TEXT, gerente_entrada TEXT, gerente_saida TEXT, vendas_cartao INTEGER, vendas_pix INTEGER, vendas_dinheiro INTEGER, quantidade_trocas INTEGER, nome_funcao_especial TEXT, quantidade_funcao_especial INTEGER, nome_arquivo TEXT, criado_em DATETIME DEFAULT CURRENT_TIMESTAMP)`);
        db.run(`CREATE TABLE IF NOT EXISTS desempenho_vendedores (id INTEGER PRIMARY KEY AUTOINCREMENT, relatorio_id INTEGER, nome_vendedor TEXT, atendimentos INTEGER, vendas INTEGER, FOREIGN KEY (relatorio_id) REFERENCES relatorios(id) ON DELETE CASCADE)`);
    });
});

// 3. MIDDLEWARES, SESSÃO E PROTEÇÃO DE ROTAS
app.use(express.static(path.join(__dirname, 'public')));
app.use(express.urlencoded({ extended: true }));
app.use(express.json());
app.use(session({ secret: 'a-chave-mais-secreta-de-todas-as-galaxias', resave: false, saveUninitialized: false, cookie: { maxAge: 24 * 60 * 60 * 1000 } }));
const requireLogin = (req, res, next) => { if (req.session && req.session.userId) return next(); else res.redirect('/login'); };
const requireAdmin = (req, res, next) => { if (req.session && req.session.role === 'admin') return next(); else res.status(403).send("Acesso negado."); };
app.get('/login', (req, res) => res.sendFile(path.join(__dirname, 'views', 'login.html')));
app.get('/', requireLogin, (req, res) => res.sendFile(path.join(__dirname, 'views', 'index.html')));
app.get('/live', requireLogin, (req, res) => res.sendFile(path.join(__dirname, 'views', 'live.html')));
app.get('/consulta', requireLogin, (req, res) => res.sendFile(path.join(__dirname, 'views', 'consulta.html')));
app.get('/demandas', requireLogin, (req, res) => res.sendFile(path.join(__dirname, 'views', 'demandas.html')));
app.get('/gerenciar-lojas', requireLogin, requireAdmin, (req, res) => res.sendFile(path.join(__dirname, 'views', 'gerenciar-lojas.html')));
app.get('/admin', requireLogin, requireAdmin, (req, res) => res.sendFile(path.join(__dirname, 'views', 'admin.html')));
app.post('/login', (req, res) => { const { username, password } = req.body; db.get('SELECT * FROM usuarios WHERE username = ?', [username], (err, user) => { if (err || !user) return res.redirect('/login?error=1'); bcrypt.compare(password, user.password, (err, result) => { if (result) { req.session.userId = user.id; req.session.username = user.username; req.session.role = user.role; res.redirect(user.role === 'admin' ? '/admin' : '/'); } else { res.redirect('/login?error=1'); } }); }); });
app.get('/logout', (req, res) => { req.session.destroy(() => res.redirect('/login')); });
app.get('/api/session-info', requireLogin, (req, res) => res.json({ username: req.session.username, role: req.session.role }));
app.get('/backup-db', requireLogin, requireAdmin, (req, res) => { const dataFormatada = new Date().toISOString().slice(0, 10); res.download(DB_PATH, `backup_relatorios_${dataFormatada}.db`); });

// 4. ROTAS DA API
app.get('/api/lojas', requireLogin, (req, res) => { db.all('SELECT * FROM lojas ORDER BY nome', (err, lojas) => res.json(lojas || [])); });
app.post('/api/lojas', requireLogin, requireAdmin, (req, res) => { const { nome, funcao_especial, observacoes, meta_tx_loja, meta_tx_monitoramento } = req.body; const funcao = funcao_especial === 'nenhuma' ? null : funcao_especial; db.run('INSERT INTO lojas (nome, funcao_especial, observacoes, meta_tx_loja, meta_tx_monitoramento) VALUES (?, ?, ?, ?, ?)', [nome, funcao, observacoes, meta_tx_loja, meta_tx_monitoramento], function(err) { if(err) return res.status(400).json({error: "Nome da loja já existe."}); res.json({ id: this.lastID }); }); });
app.put('/api/lojas/:id', requireLogin, requireAdmin, (req, res) => { const { nome, funcao_especial, observacoes, meta_tx_loja, meta_tx_monitoramento } = req.body; const funcao = funcao_especial === 'nenhuma' ? null : funcao_especial; db.run('UPDATE lojas SET nome = ?, funcao_especial = ?, observacoes = ?, meta_tx_loja = ?, meta_tx_monitoramento = ? WHERE id = ?', [nome, funcao, observacoes, meta_tx_loja, meta_tx_monitoramento, req.params.id], function(err) { if(err) return res.status(400).json({error:err.message}); res.json({ changes: this.changes }); }); });
app.delete('/api/lojas/:id', requireLogin, requireAdmin, (req, res) => { db.run('DELETE FROM lojas WHERE id = ?', req.params.id, function(err) { res.json({ changes: this.changes }); }); });
app.get('/api/demandas', requireLogin, (req, res) => { db.all("SELECT * FROM demandas WHERE status = 'pendente' ORDER BY tag DESC, criado_em ASC", (err, rows) => res.json(rows || [])); });
app.post('/api/demandas', requireLogin, requireAdmin, (req, res) => { const { loja_nome, descricao, tag } = req.body; db.run("INSERT INTO demandas (loja_nome, descricao, tag) VALUES (?, ?, ?)", [loja_nome, descricao, tag], function(err) { if (err) return res.status(500).json({error: err.message}); res.json({ id: this.lastID }); }); });
app.put('/api/demandas/:id', requireLogin, requireAdmin, (req, res) => { db.run("UPDATE demandas SET status = 'concluido' WHERE id = ?", [req.params.id], function(err) { if(err) return res.status(500).json({error: err.message}); res.json({ changes: this.changes }); }); });
app.delete('/api/demandas/:id', requireLogin, requireAdmin, (req, res) => { db.run("DELETE FROM demandas WHERE id = ?", [req.params.id], function(err) { if(err) return res.status(500).json({error: err.message}); res.json({ changes: this.changes }); }); });
app.post('/salvar', requireLogin, (req, res) => { const { loja, data, clientes_monitoramento, clientes_loja, vendas_monitoramento, vendas_loja, hora_abertura, hora_fechamento, gerente_entrada, gerente_saida, vendas_cartao, vendas_pix, vendas_dinheiro, quantidade_trocas, nome_funcao_especial, quantidade_funcao_especial, vendedores } = req.body; db.serialize(() => { db.run('BEGIN TRANSACTION'); const sqlRelatorio = `INSERT INTO relatorios (loja, data, clientes_monitoramento, clientes_loja, vendas_monitoramento, vendas_loja, hora_abertura, hora_fechamento, gerente_entrada, gerente_saida, vendas_cartao, vendas_pix, vendas_dinheiro, quantidade_trocas, nome_funcao_especial, quantidade_funcao_especial, nome_arquivo) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`; db.run(sqlRelatorio, [loja, data, clientes_monitoramento, clientes_loja, vendas_monitoramento, vendas_loja, hora_abertura, hora_fechamento, gerente_entrada, gerente_saida, vendas_cartao, vendas_pix, vendas_dinheiro, quantidade_trocas, nome_funcao_especial, quantidade_funcao_especial, ''], function(err) { if (err) { db.run('ROLLBACK'); return res.status(500).send("Erro ao salvar relatório."); } const relatorioId = this.lastID; const vendedoresArray = JSON.parse(vendedores || "[]"); if (vendedoresArray.length > 0) { const sqlVendedor = `INSERT INTO desempenho_vendedores (relatorio_id, nome_vendedor, atendimentos, vendas) VALUES (?, ?, ?, ?)`; vendedoresArray.forEach(vendedor => db.run(sqlVendedor, [relatorioId, vendedor.nome, vendedor.atendimentos, vendedor.vendas])); } const taxaConversaoLoja = clientes_loja > 0 ? ((vendas_loja / clientes_loja) * 100).toFixed(2) : 0; const taxaConversaoMonitoramento = clientes_monitoramento > 0 ? ((vendas_monitoramento / clientes_monitoramento) * 100).toFixed(2) : 0; const totalVendas = (parseInt(vendas_cartao) || 0) + (parseInt(vendas_pix) || 0) + (parseInt(vendas_dinheiro) || 0); let desempenhoEquipeTxt = vendedoresArray.map(v => { const taxaVendedor = v.atendimentos > 0 ? ((v.vendas / v.atendimentos) * 100).toFixed(2) : 0; return `${v.nome}: ${v.atendimentos} Atendimentos / ${v.vendas} Vendas / Taxa de conversão: ${taxaVendedor}%`; }).join('\n'); let funcaoEspecialTxt = ''; if (nome_funcao_especial && nome_funcao_especial.trim() !== '') { funcaoEspecialTxt = `${nome_funcao_especial}: ${quantidade_funcao_especial || 0}\n`; } const conteudoTxt = `${loja.toUpperCase()}\n\nDATA: ${new Date(data).toLocaleDateString('pt-BR', {timeZone: 'UTC'})}\n\nClientes: ${clientes_monitoramento}\nBluve: ${clientes_loja}\nVendas / Monitoramento: ${vendas_monitoramento}\nVendas / Loja: ${vendas_loja}\nTaxa de conversão da loja: ${taxaConversaoLoja}%\nTaxa de conversão do monitoramento: ${taxaConversaoMonitoramento}%\n\nAbertura: ${hora_abertura} - ${hora_fechamento}\nGerente: ${gerente_entrada} - ${gerente_saida}\nVendas em Cartão: ${vendas_cartao}\nVendas em Pix: ${vendas_pix}\nVendas em Dinheiro: ${vendas_dinheiro}\nTotal vendas: ${totalVendas}\nTroca/Devolução: ${quantidade_trocas || 0}\n${funcaoEspecialTxt}\nDesempenho Equipe:\n${desempenhoEquipeTxt}`.trim().replace(/\n\s+\n/g, '\n\n'); const nomeArquivo = `Relatorio-${loja.replace(/ /g, '_')}-${data}-${relatorioId}.txt`; fs.writeFileSync(path.join(TXT_FOLDER_PATH, nomeArquivo), conteudoTxt); db.run(`UPDATE relatorios SET nome_arquivo = ? WHERE id = ?`, [nomeArquivo, relatorioId], () => { db.run('COMMIT', (err) => { if (err) return res.status(500).send("Erro ao finalizar o salvamento."); res.redirect('/consulta?status=sucesso'); }); }); }); }); });
app.use('/relatorios_gerados', express.static(TXT_FOLDER_PATH));
app.get('/api/relatorios', requireLogin, (req, res) => { db.all(`SELECT id, loja, data, nome_arquivo FROM relatorios ORDER BY criado_em DESC`, (err, rows) => res.json({ data: rows || [] })); });
app.get('/api/relatorio/:id', requireLogin, (req, res) => { const id = req.params.id; db.get(`SELECT * FROM relatorios WHERE id = ?`, [id], (err, relatorio) => { if (!relatorio) return res.status(404).json({ error: "Relatório não encontrado." }); db.all(`SELECT * FROM desempenho_vendedores WHERE relatorio_id = ?`, [id], (err, vendedores) => res.json({ relatorio, vendedores: vendedores || [] })); }); });
app.delete('/api/relatorios/:id', requireLogin, (req, res) => { const id = req.params.id; db.get('SELECT nome_arquivo FROM relatorios WHERE id = ?', [id], (err, row) => { if (err || !row) return res.status(404).json({ error: "Relatório não encontrado." }); const caminhoArquivo = path.join(TXT_FOLDER_PATH, row.nome_arquivo || ''); fs.unlink(caminhoArquivo, (fsErr) => { if (fsErr && fsErr.code !== 'ENOENT') console.error("Aviso: não foi possível deletar o arquivo .txt:", fsErr.message); db.run('DELETE FROM relatorios WHERE id = ?', [id], function(dbErr) { if (dbErr) return res.status(500).json({ error: dbErr.message }); res.json({ message: 'Relatório deletado com sucesso', changes: this.changes }); }); }); }); });
app.get('/api/dashboard-data', requireLogin, requireAdmin, (req, res) => { const { loja, data_inicio, data_fim } = req.query; let conditions = []; const params = []; if (loja && loja !== 'todas') { conditions.push('loja = ?'); params.push(loja); } if (data_inicio && data_fim) { conditions.push('data BETWEEN ? AND ?'); params.push(data_inicio, data_fim); } const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : ''; const sql = `SELECT COALESCE(SUM(clientes_monitoramento), 0) as total_clientes_monitoramento, COALESCE(SUM(clientes_loja), 0) as total_clientes_loja, COALESCE(SUM(vendas_monitoramento), 0) as total_vendas_monitoramento, COALESCE(SUM(vendas_loja), 0) as total_vendas_loja FROM relatorios ${whereClause}`; db.get(sql, params, (err, row) => { if (err) return res.status(500).json({ error: err.message }); row.tx_conversao_monitoramento = row.total_clientes_monitoramento > 0 ? ((row.total_vendas_monitoramento / row.total_clientes_monitoramento) * 100).toFixed(2) : 0; row.tx_conversao_loja = row.total_clientes_loja > 0 ? ((row.total_vendas_loja / row.total_clientes_loja) * 100).toFixed(2) : 0; res.json(row); }); });
app.get('/api/ranking', requireLogin, requireAdmin, (req, res) => { const { data_inicio, data_fim } = req.query; let whereClause = ''; const params = []; if (data_inicio && data_fim) { whereClause = 'WHERE data BETWEEN ? AND ?'; params.push(data_inicio, data_fim); } const sql = `SELECT loja, SUM(clientes_monitoramento) as clientes_m, SUM(vendas_monitoramento) as vendas_m, SUM(clientes_loja) as clientes_l, SUM(vendas_loja) as vendas_l, (SUM(vendas_monitoramento) * 100.0 / SUM(clientes_monitoramento)) as tx_monitoramento, (SUM(vendas_loja) * 100.0 / SUM(clientes_loja)) as tx_loja FROM relatorios ${whereClause} GROUP BY loja HAVING SUM(clientes_monitoramento) > 0 AND SUM(clientes_loja) > 0`; db.all(sql, params, (err, rows) => { if (err) return res.status(500).json({ error: err.message }); res.json(rows || []); }); });
app.get('/api/export-excel', requireLogin, requireAdmin, async (req, res) => { const { month, year } = req.query; if (!month || !year) { return res.status(400).send("Mês e ano são obrigatórios."); } const periodo = `${year}-${String(month).padStart(2, '0')}`; const fileName = `Relatorios-${year}-${month}.xlsx`; try { const workbook = new ExcelJS.Workbook(); const lojas = await new Promise((resolve, reject) => { db.all('SELECT * FROM lojas ORDER BY nome', (err, rows) => { if (err) reject(err); resolve(rows); }); }); for (const loja of lojas) { const worksheet = workbook.addWorksheet(loja.nome); worksheet.columns = [{ header: 'Data', key: 'data', width: 12 }, { header: 'Vendas Loja', key: 'vendas_loja', width: 15 }, { header: 'Atendimentos Loja', key: 'clientes_loja', width: 20 }, { header: 'Tx. Conversão Diária', key: 'tx_diaria', width: 22, style: { numFmt: '0.00"%"' } }, { header: 'Tx. Conversão Semanal', key: 'tx_semanal', width: 22, style: { numFmt: '0.00"%"' } }, { header: 'Abertura', key: 'hora_abertura', width: 12 }, { header: 'Fechamento', key: 'hora_fechamento', width: 12 }, { header: `Qtd. ${loja.funcao_especial || 'Função Esp.'}`, key: 'funcao_especial', width: 20 }]; worksheet.getRow(1).font = { bold: true }; const relatorios = await new Promise((resolve, reject) => { const sql = `SELECT * FROM relatorios WHERE loja = ? AND strftime('%Y-%m', data) = ? ORDER BY data ASC`; db.all(sql, [loja.nome, periodo], (err, rows) => { if (err) reject(err); resolve(rows); }); }); for (let i = 0; i < relatorios.length; i++) { const relatorio = relatorios[i]; const tx_diaria = relatorio.clientes_loja > 0 ? (relatorio.vendas_loja / relatorio.clientes_loja) * 100 : 0; const inicioSemana = Math.max(0, i - 6); const relatoriosDaSemana = relatorios.slice(inicioSemana, i + 1); const totalVendasSemana = relatoriosDaSemana.reduce((sum, r) => sum + r.vendas_loja, 0); const totalClientesSemana = relatoriosDaSemana.reduce((sum, r) => sum + r.clientes_loja, 0); const tx_semanal = totalClientesSemana > 0 ? (totalVendasSemana / totalClientesSemana) * 100 : 0; worksheet.addRow({ data: relatorio.data, vendas_loja: relatorio.vendas_loja, clientes_loja: relatorio.clientes_loja, tx_diaria: tx_diaria, tx_semanal: tx_semanal, hora_abertura: relatorio.hora_abertura, hora_fechamento: relatorio.hora_fechamento, funcao_especial: relatorio.nome_funcao_especial === loja.funcao_especial ? relatorio.quantidade_funcao_especial : 0 }); } } res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'); res.setHeader('Content-Disposition', `attachment; filename=${fileName}`); await workbook.xlsx.write(res); res.end(); } catch (error) { console.error("Erro ao gerar Excel:", error); res.status(500).send("Não foi possível gerar o arquivo Excel."); } });
app.get('/api/insights', requireLogin, requireAdmin, (req, res) => { const sql = `SELECT r.loja, r.data, r.clientes_loja, r.vendas_loja, l.meta_tx_loja FROM relatorios r INNER JOIN (SELECT loja, MAX(data) as max_data FROM relatorios GROUP BY loja) as sub ON r.loja = sub.loja AND r.data = sub.max_data INNER JOIN lojas l ON r.loja = l.nome`; db.all(sql, [], (err, rows) => { if (err) return res.status(500).json({ error: err.message }); const insights = rows.map(row => { const tx_atual = row.clientes_loja > 0 ? (row.vendas_loja / row.clientes_loja) * 100 : 0; const meta = row.meta_tx_loja; let status, cor; if (tx_atual >= meta) { status = "Ótimo"; cor = "success"; } else if (tx_atual >= meta * 0.75) { status = "Médio"; cor = "warning"; } else { status = "Ruim"; cor = "danger"; } return { loja: row.loja, status, tx_atual: tx_atual.toFixed(2), meta }; }); res.json(insights); }); });

// 7. INICIAR O SERVIDOR
app.listen(PORT, '0.0.0.0', () => console.log(`Servidor - ON Acesse em http://localhost:${PORT}`));